h1. SVM

A (simple, small, stack-based, stupid) VM.

I wrote this because I wanted something to use as a compilation target while I played with toy compilers, and because writing it was easier than understanding LLVM's documentation. I am not even kidding.

Besides, I could get neither libjit nor llvmruby to build on OSX.

h2. SVM design

SVM is a stack-based machine where programs are organized into functions. Each function has:

* a name
* a return type
* a set of parameters (named, with static types, can be empty)
* a set of variables (named, with static types, can be empty)
* a list of instructions

SVM is strange in that there is no textual representation of its code. Eventually there will be a binary object file format, but for right now, code translates easily to YAML files. Most of the time you'll use  @SVM::Builder@ to write it anyway.

h2. How to write an SVM function

To start off with, make an instance of @SVM::Builder@ and give it a name:

@b = SVM::Builder.new "square"@

Our function will take a number and return its square, so let's set a return type and add a parameter:

@b.return_type = :number@

@b.param :n, :number@

Now, time to start coding. We'll load the parameter on to the stack, duplicate it, then multiply the two copies. Finally, we'll return (every function must explicitly return) which returns the value on top of the stack:

bc. b.load :n
b.dup
b.mul
b.return

h2. Available instructions

*How to read this:*

*_name_* (_argument_) [_data types_]: _description_

The descriptions use the standard terminology: the value at the top of the stack is x, the value beneath it is y, the one beneath that is z

All instructions take either zero or one argument. If an instruction assumes something about the state of the stack, that's listed in the _data types_ block.

h3. Stack operations

* *return* [x:anything]: Exit the function and return x
* *push*(number): Push the argument to the top of the stack
* *dup* [x:anything]: Push x to the top of the stack (shallow copy)
* *swap* [y:anything x:anything]: Swap x and y

h3. Variable operations

* *load*(name): Look up the variable given by name from params/vars, and push its value
* *store*(name) [x:anything]: Store x into the param/var given by name

h3. Arithmetic

* *add* [y:number x:number]: Pop x and y, push x+y
* *sub* [y:number x:number]: Pop x and y, push y-x
* *mul* [y:number x:number]: Pop x and y, push x*y
* *div* [y:number x:number]: Pop x and y, push y/x
* *mod* [y:number x:number]: Pop x and y, push y%x
* *dec* [x:number]: Pop x, push x-1
* *inc* [x:number]: Pop x, push x+1

h3. Jumps

Jump to the given address if the conditions match. Conditions only work on numeric values

* *jmp*(address): Jump unconditionally
* *jmplt*(address) [y:number x:number]: Pop x and y, jump if x < y
* *jmpgt*(address) [y:number x:number]: Pop x and y, jump if x > y
* *jmple*(address) [y:number x:number]: Pop x and y, jump if x <= y
* *jmpge*(address) [y:number x:number]: Pop x and y, jump if x >= y
* *jmpe*(address) [y:number x:number]: Pop x and y, jump if x == y
* *jmpne*(address) [y:number x:number]: Pop x and y, jump if x != y
* *jmpz*(address) [x:number]: Pop x, jump if x == 0
* *jmpnz*(address) [x:number]: Pop x, jump if x != 0

h3. Array operations

Arrays can hold any number of elements, and the elements don't have to be the same type

* *anew*: Create a new array and push it on to the stack
* *size* [x:array]: Pop x, push the number of elements in it
* *aget* [y:array x:number]: Pop x and y, push y[x]
* *aset* [z:array y:number x:anything]: Pop x, y, and z, store x in z[y]
* *apush* [y:array x:anything]: Pop x and y, store x at the end of y

h3. Hash operations

Hashes hold key/value pairs. Any types can be used as keys or values

* *hnew*: Create a new hash and push it on to the stack
* *hget* [y:hash x:anything]: Pop x and y, push y[x]
* *hset* [z:hash y:anything x:anything]: Pop x, y, and z, store x in z[y]
